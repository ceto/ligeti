!function($) {
    "use strict";
    var Collapse = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, $.fn.collapse.defaults, options);
        if (this.options.parent) {
            this.$parent = $(this.options.parent);
        }
        this.options.toggle && this.toggle();
    };
    Collapse.prototype = {
        constructor: Collapse,
        dimension: function() {
            var hasWidth = this.$element.hasClass("width");
            return hasWidth ? "width" : "height";
        },
        show: function() {
            var dimension, scroll, actives, hasData;
            if (this.transitioning || this.$element.hasClass("in")) return;
            dimension = this.dimension();
            scroll = $.camelCase([ "scroll", dimension ].join("-"));
            actives = this.$parent && this.$parent.find("> .accordion-group > .in");
            if (actives && actives.length) {
                hasData = actives.data("collapse");
                if (hasData && hasData.transitioning) return;
                actives.collapse("hide");
                hasData || actives.data("collapse", null);
            }
            this.$element[dimension](0);
            this.transition("addClass", $.Event("show"), "shown");
            $.support.transition && this.$element[dimension](this.$element[0][scroll]);
        },
        hide: function() {
            var dimension;
            if (this.transitioning || !this.$element.hasClass("in")) return;
            dimension = this.dimension();
            this.reset(this.$element[dimension]());
            this.transition("removeClass", $.Event("hide"), "hidden");
            this.$element[dimension](0);
        },
        reset: function(size) {
            var dimension = this.dimension();
            this.$element.removeClass("collapse")[dimension](size || "auto")[0].offsetWidth;
            this.$element[size !== null ? "addClass" : "removeClass"]("collapse");
            return this;
        },
        transition: function(method, startEvent, completeEvent) {
            var that = this, complete = function() {
                if (startEvent.type == "show") that.reset();
                that.transitioning = 0;
                that.$element.trigger(completeEvent);
            };
            this.$element.trigger(startEvent);
            if (startEvent.isDefaultPrevented()) return;
            this.transitioning = 1;
            this.$element[method]("in");
            $.support.transition && this.$element.hasClass("collapse") ? this.$element.one($.support.transition.end, complete) : complete();
        },
        toggle: function() {
            this[this.$element.hasClass("in") ? "hide" : "show"]();
        }
    };
    var old = $.fn.collapse;
    $.fn.collapse = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("collapse"), options = $.extend({}, $.fn.collapse.defaults, $this.data(), typeof option == "object" && option);
            if (!data) $this.data("collapse", data = new Collapse(this, options));
            if (typeof option == "string") data[option]();
        });
    };
    $.fn.collapse.defaults = {
        toggle: true
    };
    $.fn.collapse.Constructor = Collapse;
    $.fn.collapse.noConflict = function() {
        $.fn.collapse = old;
        return this;
    };
    $(document).on("click.collapse.data-api", "[data-toggle=collapse]", function(e) {
        var $this = $(this), href, target = $this.attr("data-target") || e.preventDefault() || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, ""), option = $(target).data("collapse") ? "toggle" : $this.data();
        $this[$(target).hasClass("in") ? "addClass" : "removeClass"]("collapsed");
        $(target).collapse(option);
    });
}(window.jQuery);

!function($) {
    "use strict";
    var Modal = function(element, options) {
        this.options = options;
        this.$element = $(element).delegate('[data-dismiss="modal"]', "click.dismiss.modal", $.proxy(this.hide, this));
        this.options.remote && this.$element.find(".modal-body").load(this.options.remote);
    };
    Modal.prototype = {
        constructor: Modal,
        toggle: function() {
            return this[!this.isShown ? "show" : "hide"]();
        },
        show: function() {
            var that = this, e = $.Event("show");
            this.$element.trigger(e);
            if (this.isShown || e.isDefaultPrevented()) return;
            this.isShown = true;
            this.escape();
            this.backdrop(function() {
                var transition = $.support.transition && that.$element.hasClass("fade");
                if (!that.$element.parent().length) {
                    that.$element.appendTo(document.body);
                }
                that.$element.show();
                if (transition) {
                    that.$element[0].offsetWidth;
                }
                that.$element.addClass("in").attr("aria-hidden", false);
                that.enforceFocus();
                transition ? that.$element.one($.support.transition.end, function() {
                    that.$element.focus().trigger("shown");
                }) : that.$element.focus().trigger("shown");
            });
        },
        hide: function(e) {
            e && e.preventDefault();
            var that = this;
            e = $.Event("hide");
            this.$element.trigger(e);
            if (!this.isShown || e.isDefaultPrevented()) return;
            this.isShown = false;
            this.escape();
            $(document).off("focusin.modal");
            this.$element.removeClass("in").attr("aria-hidden", true);
            $.support.transition && this.$element.hasClass("fade") ? this.hideWithTransition() : this.hideModal();
        },
        enforceFocus: function() {
            var that = this;
            $(document).on("focusin.modal", function(e) {
                if (that.$element[0] !== e.target && !that.$element.has(e.target).length) {
                    that.$element.focus();
                }
            });
        },
        escape: function() {
            var that = this;
            if (this.isShown && this.options.keyboard) {
                this.$element.on("keyup.dismiss.modal", function(e) {
                    e.which == 27 && that.hide();
                });
            } else if (!this.isShown) {
                this.$element.off("keyup.dismiss.modal");
            }
        },
        hideWithTransition: function() {
            var that = this, timeout = setTimeout(function() {
                that.$element.off($.support.transition.end);
                that.hideModal();
            }, 500);
            this.$element.one($.support.transition.end, function() {
                clearTimeout(timeout);
                that.hideModal();
            });
        },
        hideModal: function() {
            var that = this;
            this.$element.hide();
            this.backdrop(function() {
                that.removeBackdrop();
                that.$element.trigger("hidden");
            });
        },
        removeBackdrop: function() {
            this.$backdrop && this.$backdrop.remove();
            this.$backdrop = null;
        },
        backdrop: function(callback) {
            var that = this, animate = this.$element.hasClass("fade") ? "fade" : "";
            if (this.isShown && this.options.backdrop) {
                var doAnimate = $.support.transition && animate;
                this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />').appendTo(document.body);
                this.$backdrop.click(this.options.backdrop == "static" ? $.proxy(this.$element[0].focus, this.$element[0]) : $.proxy(this.hide, this));
                if (doAnimate) this.$backdrop[0].offsetWidth;
                this.$backdrop.addClass("in");
                if (!callback) return;
                doAnimate ? this.$backdrop.one($.support.transition.end, callback) : callback();
            } else if (!this.isShown && this.$backdrop) {
                this.$backdrop.removeClass("in");
                $.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one($.support.transition.end, callback) : callback();
            } else if (callback) {
                callback();
            }
        }
    };
    var old = $.fn.modal;
    $.fn.modal = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("modal"), options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == "object" && option);
            if (!data) $this.data("modal", data = new Modal(this, options));
            if (typeof option == "string") data[option](); else if (options.show) data.show();
        });
    };
    $.fn.modal.defaults = {
        backdrop: true,
        keyboard: true,
        show: true
    };
    $.fn.modal.Constructor = Modal;
    $.fn.modal.noConflict = function() {
        $.fn.modal = old;
        return this;
    };
    $(document).on("click.modal.data-api", '[data-toggle="modal"]', function(e) {
        var $this = $(this), href = $this.attr("href"), $target = $($this.attr("data-target") || href && href.replace(/.*(?=#[^\s]+$)/, "")), option = $target.data("modal") ? "toggle" : $.extend({
            remote: !/#/.test(href) && href
        }, $target.data(), $this.data());
        e.preventDefault();
        $target.modal(option).one("hide", function() {
            $this.focus();
        });
    });
}(window.jQuery);

!function($) {
    "use strict";
    var Tooltip = function(element, options) {
        this.init("tooltip", element, options);
    };
    Tooltip.prototype = {
        constructor: Tooltip,
        init: function(type, element, options) {
            var eventIn, eventOut, triggers, trigger, i;
            this.type = type;
            this.$element = $(element);
            this.options = this.getOptions(options);
            this.enabled = true;
            triggers = this.options.trigger.split(" ");
            for (i = triggers.length; i--; ) {
                trigger = triggers[i];
                if (trigger == "click") {
                    this.$element.on("click." + this.type, this.options.selector, $.proxy(this.toggle, this));
                } else if (trigger != "manual") {
                    eventIn = trigger == "hover" ? "mouseenter" : "focus";
                    eventOut = trigger == "hover" ? "mouseleave" : "blur";
                    this.$element.on(eventIn + "." + this.type, this.options.selector, $.proxy(this.enter, this));
                    this.$element.on(eventOut + "." + this.type, this.options.selector, $.proxy(this.leave, this));
                }
            }
            this.options.selector ? this._options = $.extend({}, this.options, {
                trigger: "manual",
                selector: ""
            }) : this.fixTitle();
        },
        getOptions: function(options) {
            options = $.extend({}, $.fn[this.type].defaults, this.$element.data(), options);
            if (options.delay && typeof options.delay == "number") {
                options.delay = {
                    show: options.delay,
                    hide: options.delay
                };
            }
            return options;
        },
        enter: function(e) {
            var defaults = $.fn[this.type].defaults, options = {}, self;
            this._options && $.each(this._options, function(key, value) {
                if (defaults[key] != value) options[key] = value;
            }, this);
            self = $(e.currentTarget)[this.type](options).data(this.type);
            if (!self.options.delay || !self.options.delay.show) return self.show();
            clearTimeout(this.timeout);
            self.hoverState = "in";
            this.timeout = setTimeout(function() {
                if (self.hoverState == "in") self.show();
            }, self.options.delay.show);
        },
        leave: function(e) {
            var self = $(e.currentTarget)[this.type](this._options).data(this.type);
            if (this.timeout) clearTimeout(this.timeout);
            if (!self.options.delay || !self.options.delay.hide) return self.hide();
            self.hoverState = "out";
            this.timeout = setTimeout(function() {
                if (self.hoverState == "out") self.hide();
            }, self.options.delay.hide);
        },
        show: function() {
            var $tip, pos, actualWidth, actualHeight, placement, tp, e = $.Event("show");
            if (this.hasContent() && this.enabled) {
                this.$element.trigger(e);
                if (e.isDefaultPrevented()) return;
                $tip = this.tip();
                this.setContent();
                if (this.options.animation) {
                    $tip.addClass("fade");
                }
                placement = typeof this.options.placement == "function" ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;
                $tip.detach().css({
                    top: 0,
                    left: 0,
                    display: "block"
                });
                this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
                pos = this.getPosition();
                actualWidth = $tip[0].offsetWidth;
                actualHeight = $tip[0].offsetHeight;
                switch (placement) {
                  case "bottom":
                    tp = {
                        top: pos.top + pos.height,
                        left: pos.left + pos.width / 2 - actualWidth / 2
                    };
                    break;

                  case "top":
                    tp = {
                        top: pos.top - actualHeight,
                        left: pos.left + pos.width / 2 - actualWidth / 2
                    };
                    break;

                  case "left":
                    tp = {
                        top: pos.top + pos.height / 2 - actualHeight / 2,
                        left: pos.left - actualWidth
                    };
                    break;

                  case "right":
                    tp = {
                        top: pos.top + pos.height / 2 - actualHeight / 2,
                        left: pos.left + pos.width
                    };
                    break;
                }
                this.applyPlacement(tp, placement);
                this.$element.trigger("shown");
            }
        },
        applyPlacement: function(offset, placement) {
            var $tip = this.tip(), width = $tip[0].offsetWidth, height = $tip[0].offsetHeight, actualWidth, actualHeight, delta, replace;
            $tip.offset(offset).addClass(placement).addClass("in");
            actualWidth = $tip[0].offsetWidth;
            actualHeight = $tip[0].offsetHeight;
            if (placement == "top" && actualHeight != height) {
                offset.top = offset.top + height - actualHeight;
                replace = true;
            }
            if (placement == "bottom" || placement == "top") {
                delta = 0;
                if (offset.left < 0) {
                    delta = offset.left * -2;
                    offset.left = 0;
                    $tip.offset(offset);
                    actualWidth = $tip[0].offsetWidth;
                    actualHeight = $tip[0].offsetHeight;
                }
                this.replaceArrow(delta - width + actualWidth, actualWidth, "left");
            } else {
                this.replaceArrow(actualHeight - height, actualHeight, "top");
            }
            if (replace) $tip.offset(offset);
        },
        replaceArrow: function(delta, dimension, position) {
            this.arrow().css(position, delta ? 50 * (1 - delta / dimension) + "%" : "");
        },
        setContent: function() {
            var $tip = this.tip(), title = this.getTitle();
            $tip.find(".tooltip-inner")[this.options.html ? "html" : "text"](title);
            $tip.removeClass("fade in top bottom left right");
        },
        hide: function() {
            var that = this, $tip = this.tip(), e = $.Event("hide");
            this.$element.trigger(e);
            if (e.isDefaultPrevented()) return;
            $tip.removeClass("in");
            function removeWithAnimation() {
                var timeout = setTimeout(function() {
                    $tip.off($.support.transition.end).detach();
                }, 500);
                $tip.one($.support.transition.end, function() {
                    clearTimeout(timeout);
                    $tip.detach();
                });
            }
            $.support.transition && this.$tip.hasClass("fade") ? removeWithAnimation() : $tip.detach();
            this.$element.trigger("hidden");
            return this;
        },
        fixTitle: function() {
            var $e = this.$element;
            if ($e.attr("title") || typeof $e.attr("data-original-title") != "string") {
                $e.attr("data-original-title", $e.attr("title") || "").attr("title", "");
            }
        },
        hasContent: function() {
            return this.getTitle();
        },
        getPosition: function() {
            var el = this.$element[0];
            return $.extend({}, typeof el.getBoundingClientRect == "function" ? el.getBoundingClientRect() : {
                width: el.offsetWidth,
                height: el.offsetHeight
            }, this.$element.offset());
        },
        getTitle: function() {
            var title, $e = this.$element, o = this.options;
            title = $e.attr("data-original-title") || (typeof o.title == "function" ? o.title.call($e[0]) : o.title);
            return title;
        },
        tip: function() {
            return this.$tip = this.$tip || $(this.options.template);
        },
        arrow: function() {
            return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow");
        },
        validate: function() {
            if (!this.$element[0].parentNode) {
                this.hide();
                this.$element = null;
                this.options = null;
            }
        },
        enable: function() {
            this.enabled = true;
        },
        disable: function() {
            this.enabled = false;
        },
        toggleEnabled: function() {
            this.enabled = !this.enabled;
        },
        toggle: function(e) {
            var self = e ? $(e.currentTarget)[this.type](this._options).data(this.type) : this;
            self.tip().hasClass("in") ? self.hide() : self.show();
        },
        destroy: function() {
            this.hide().$element.off("." + this.type).removeData(this.type);
        }
    };
    var old = $.fn.tooltip;
    $.fn.tooltip = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("tooltip"), options = typeof option == "object" && option;
            if (!data) $this.data("tooltip", data = new Tooltip(this, options));
            if (typeof option == "string") data[option]();
        });
    };
    $.fn.tooltip.Constructor = Tooltip;
    $.fn.tooltip.defaults = {
        animation: true,
        placement: "top",
        selector: false,
        template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: false,
        container: false
    };
    $.fn.tooltip.noConflict = function() {
        $.fn.tooltip = old;
        return this;
    };
}(window.jQuery);

!function($) {
    "use strict";
    var Popover = function(element, options) {
        this.init("popover", element, options);
    };
    Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype, {
        constructor: Popover,
        setContent: function() {
            var $tip = this.tip(), title = this.getTitle(), content = this.getContent();
            $tip.find(".popover-title")[this.options.html ? "html" : "text"](title);
            $tip.find(".popover-content")[this.options.html ? "html" : "text"](content);
            $tip.removeClass("fade top bottom left right in");
        },
        hasContent: function() {
            return this.getTitle() || this.getContent();
        },
        getContent: function() {
            var content, $e = this.$element, o = this.options;
            content = (typeof o.content == "function" ? o.content.call($e[0]) : o.content) || $e.attr("data-content");
            return content;
        },
        tip: function() {
            if (!this.$tip) {
                this.$tip = $(this.options.template);
            }
            return this.$tip;
        },
        destroy: function() {
            this.hide().$element.off("." + this.type).removeData(this.type);
        }
    });
    var old = $.fn.popover;
    $.fn.popover = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("popover"), options = typeof option == "object" && option;
            if (!data) $this.data("popover", data = new Popover(this, options));
            if (typeof option == "string") data[option]();
        });
    };
    $.fn.popover.Constructor = Popover;
    $.fn.popover.defaults = $.extend({}, $.fn.tooltip.defaults, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    });
    $.fn.popover.noConflict = function() {
        $.fn.popover = old;
        return this;
    };
}(window.jQuery);

!function($) {
    "use strict";
    $(function() {
        $.support.transition = function() {
            var transitionEnd = function() {
                var el = document.createElement("bootstrap"), transEndEventNames = {
                    WebkitTransition: "webkitTransitionEnd",
                    MozTransition: "transitionend",
                    OTransition: "oTransitionEnd otransitionend",
                    transition: "transitionend"
                }, name;
                for (name in transEndEventNames) {
                    if (el.style[name] !== undefined) {
                        return transEndEventNames[name];
                    }
                }
            }();
            return transitionEnd && {
                end: transitionEnd
            };
        }();
    });
}(window.jQuery);

!function(t, i) {
    "use strict";
    var s, e = t.document, n = e.documentElement, o = t.Modernizr, r = function(t) {
        return t.charAt(0).toUpperCase() + t.slice(1);
    }, a = "Moz Webkit O Ms".split(" "), h = function(t) {
        var i, s = n.style;
        if ("string" == typeof s[t]) return t;
        t = r(t);
        for (var e = 0, o = a.length; o > e; e++) if (i = a[e] + t, "string" == typeof s[i]) return i;
    }, l = h("transform"), u = h("transitionProperty"), c = {
        csstransforms: function() {
            return !!l;
        },
        csstransforms3d: function() {
            var t = !!h("perspective");
            if (t && "webkitPerspective" in n.style) {
                var s = i("<style>@media (transform-3d),(-webkit-transform-3d){#modernizr{height:3px}}</style>").appendTo("head"), e = i('<div id="modernizr" />').appendTo("html");
                t = 3 === e.height(), e.remove(), s.remove();
            }
            return t;
        },
        csstransitions: function() {
            return !!u;
        }
    };
    if (o) for (s in c) o.hasOwnProperty(s) || o.addTest(s, c[s]); else {
        o = t.Modernizr = {
            _version: "1.6ish: miniModernizr for Isotope"
        };
        var d, f = " ";
        for (s in c) d = c[s](), o[s] = d, f += " " + (d ? "" : "no-") + s;
        i("html").addClass(f);
    }
    if (o.csstransforms) {
        var m = o.csstransforms3d ? {
            translate: function(t) {
                return "translate3d(" + t[0] + "px, " + t[1] + "px, 0) ";
            },
            scale: function(t) {
                return "scale3d(" + t + ", " + t + ", 1) ";
            }
        } : {
            translate: function(t) {
                return "translate(" + t[0] + "px, " + t[1] + "px) ";
            },
            scale: function(t) {
                return "scale(" + t + ") ";
            }
        }, p = function(t, s, e) {
            var n, o, r = i.data(t, "isoTransform") || {}, a = {}, h = {};
            a[s] = e, i.extend(r, a);
            for (n in r) o = r[n], h[n] = m[n](o);
            var u = h.translate || "", c = h.scale || "", d = u + c;
            i.data(t, "isoTransform", r), t.style[l] = d;
        };
        i.cssNumber.scale = !0, i.cssHooks.scale = {
            set: function(t, i) {
                p(t, "scale", i);
            },
            get: function(t) {
                var s = i.data(t, "isoTransform");
                return s && s.scale ? s.scale : 1;
            }
        }, i.fx.step.scale = function(t) {
            i.cssHooks.scale.set(t.elem, t.now + t.unit);
        }, i.cssNumber.translate = !0, i.cssHooks.translate = {
            set: function(t, i) {
                p(t, "translate", i);
            },
            get: function(t) {
                var s = i.data(t, "isoTransform");
                return s && s.translate ? s.translate : [ 0, 0 ];
            }
        };
    }
    var y, g;
    o.csstransitions && (y = {
        WebkitTransitionProperty: "webkitTransitionEnd",
        MozTransitionProperty: "transitionend",
        OTransitionProperty: "oTransitionEnd otransitionend",
        transitionProperty: "transitionend"
    }[u], g = h("transitionDuration"));
    var v, _ = i.event, A = i.event.handle ? "handle" : "dispatch";
    _.special.smartresize = {
        setup: function() {
            i(this).bind("resize", _.special.smartresize.handler);
        },
        teardown: function() {
            i(this).unbind("resize", _.special.smartresize.handler);
        },
        handler: function(t, i) {
            var s = this, e = arguments;
            t.type = "smartresize", v && clearTimeout(v), v = setTimeout(function() {
                _[A].apply(s, e);
            }, "execAsap" === i ? 0 : 100);
        }
    }, i.fn.smartresize = function(t) {
        return t ? this.bind("smartresize", t) : this.trigger("smartresize", [ "execAsap" ]);
    }, i.Isotope = function(t, s, e) {
        this.element = i(s), this._create(t), this._init(e);
    };
    var w = [ "width", "height" ], C = i(t);
    i.Isotope.settings = {
        resizable: !0,
        layoutMode: "masonry",
        containerClass: "isotope",
        itemClass: "isotope-item",
        hiddenClass: "isotope-hidden",
        hiddenStyle: {
            opacity: 0,
            scale: .001
        },
        visibleStyle: {
            opacity: 1,
            scale: 1
        },
        containerStyle: {
            position: "relative",
            overflow: "hidden"
        },
        animationEngine: "best-available",
        animationOptions: {
            queue: !1,
            duration: 800
        },
        sortBy: "original-order",
        sortAscending: !0,
        resizesContainer: !0,
        transformsEnabled: !0,
        itemPositionDataEnabled: !1
    }, i.Isotope.prototype = {
        _create: function(t) {
            this.options = i.extend({}, i.Isotope.settings, t), this.styleQueue = [], this.elemCount = 0;
            var s = this.element[0].style;
            this.originalStyle = {};
            var e = w.slice(0);
            for (var n in this.options.containerStyle) e.push(n);
            for (var o = 0, r = e.length; r > o; o++) n = e[o], this.originalStyle[n] = s[n] || "";
            this.element.css(this.options.containerStyle), this._updateAnimationEngine(), this._updateUsingTransforms();
            var a = {
                "original-order": function(t, i) {
                    return i.elemCount++, i.elemCount;
                },
                random: function() {
                    return Math.random();
                }
            };
            this.options.getSortData = i.extend(this.options.getSortData, a), this.reloadItems(), 
            this.offset = {
                left: parseInt(this.element.css("padding-left") || 0, 10),
                top: parseInt(this.element.css("padding-top") || 0, 10)
            };
            var h = this;
            setTimeout(function() {
                h.element.addClass(h.options.containerClass);
            }, 0), this.options.resizable && C.bind("smartresize.isotope", function() {
                h.resize();
            }), this.element.delegate("." + this.options.hiddenClass, "click", function() {
                return !1;
            });
        },
        _getAtoms: function(t) {
            var i = this.options.itemSelector, s = i ? t.filter(i).add(t.find(i)) : t, e = {
                position: "absolute"
            };
            return s = s.filter(function(t, i) {
                return 1 === i.nodeType;
            }), this.usingTransforms && (e.left = 0, e.top = 0), s.css(e).addClass(this.options.itemClass), 
            this.updateSortData(s, !0), s;
        },
        _init: function(t) {
            this.$filteredAtoms = this._filter(this.$allAtoms), this._sort(), this.reLayout(t);
        },
        option: function(t) {
            if (i.isPlainObject(t)) {
                this.options = i.extend(!0, this.options, t);
                var s;
                for (var e in t) s = "_update" + r(e), this[s] && this[s]();
            }
        },
        _updateAnimationEngine: function() {
            var t, i = this.options.animationEngine.toLowerCase().replace(/[ _\-]/g, "");
            switch (i) {
              case "css":
              case "none":
                t = !1;
                break;

              case "jquery":
                t = !0;
                break;

              default:
                t = !o.csstransitions;
            }
            this.isUsingJQueryAnimation = t, this._updateUsingTransforms();
        },
        _updateTransformsEnabled: function() {
            this._updateUsingTransforms();
        },
        _updateUsingTransforms: function() {
            var t = this.usingTransforms = this.options.transformsEnabled && o.csstransforms && o.csstransitions && !this.isUsingJQueryAnimation;
            t || (delete this.options.hiddenStyle.scale, delete this.options.visibleStyle.scale), 
            this.getPositionStyles = t ? this._translate : this._positionAbs;
        },
        _filter: function(t) {
            var i = "" === this.options.filter ? "*" : this.options.filter;
            if (!i) return t;
            var s = this.options.hiddenClass, e = "." + s, n = t.filter(e), o = n;
            if ("*" !== i) {
                o = n.filter(i);
                var r = t.not(e).not(i).addClass(s);
                this.styleQueue.push({
                    $el: r,
                    style: this.options.hiddenStyle
                });
            }
            return this.styleQueue.push({
                $el: o,
                style: this.options.visibleStyle
            }), o.removeClass(s), t.filter(i);
        },
        updateSortData: function(t, s) {
            var e, n, o = this, r = this.options.getSortData;
            t.each(function() {
                e = i(this), n = {};
                for (var t in r) n[t] = s || "original-order" !== t ? r[t](e, o) : i.data(this, "isotope-sort-data")[t];
                i.data(this, "isotope-sort-data", n);
            });
        },
        _sort: function() {
            var t = this.options.sortBy, i = this._getSorter, s = this.options.sortAscending ? 1 : -1, e = function(e, n) {
                var o = i(e, t), r = i(n, t);
                return o === r && "original-order" !== t && (o = i(e, "original-order"), r = i(n, "original-order")), 
                (o > r ? 1 : r > o ? -1 : 0) * s;
            };
            this.$filteredAtoms.sort(e);
        },
        _getSorter: function(t, s) {
            return i.data(t, "isotope-sort-data")[s];
        },
        _translate: function(t, i) {
            return {
                translate: [ t, i ]
            };
        },
        _positionAbs: function(t, i) {
            return {
                left: t,
                top: i
            };
        },
        _pushPosition: function(t, i, s) {
            i = Math.round(i + this.offset.left), s = Math.round(s + this.offset.top);
            var e = this.getPositionStyles(i, s);
            this.styleQueue.push({
                $el: t,
                style: e
            }), this.options.itemPositionDataEnabled && t.data("isotope-item-position", {
                x: i,
                y: s
            });
        },
        layout: function(t, i) {
            var s = this.options.layoutMode;
            if (this["_" + s + "Layout"](t), this.options.resizesContainer) {
                var e = this["_" + s + "GetContainerSize"]();
                this.styleQueue.push({
                    $el: this.element,
                    style: e
                });
            }
            this._processStyleQueue(t, i), this.isLaidOut = !0;
        },
        _processStyleQueue: function(t, s) {
            var e, n, r, a, h = this.isLaidOut ? this.isUsingJQueryAnimation ? "animate" : "css" : "css", l = this.options.animationOptions, u = this.options.onLayout;
            if (n = function(t, i) {
                i.$el[h](i.style, l);
            }, this._isInserting && this.isUsingJQueryAnimation) n = function(t, i) {
                e = i.$el.hasClass("no-transition") ? "css" : h, i.$el[e](i.style, l);
            }; else if (s || u || l.complete) {
                var c = !1, d = [ s, u, l.complete ], f = this;
                if (r = !0, a = function() {
                    if (!c) {
                        for (var i, s = 0, e = d.length; e > s; s++) i = d[s], "function" == typeof i && i.call(f.element, t, f);
                        c = !0;
                    }
                }, this.isUsingJQueryAnimation && "animate" === h) l.complete = a, r = !1; else if (o.csstransitions) {
                    for (var m, p = 0, v = this.styleQueue[0], _ = v && v.$el; !_ || !_.length; ) {
                        if (m = this.styleQueue[p++], !m) return;
                        _ = m.$el;
                    }
                    var A = parseFloat(getComputedStyle(_[0])[g]);
                    A > 0 && (n = function(t, i) {
                        i.$el[h](i.style, l).one(y, a);
                    }, r = !1);
                }
            }
            i.each(this.styleQueue, n), r && a(), this.styleQueue = [];
        },
        resize: function() {
            this["_" + this.options.layoutMode + "ResizeChanged"]() && this.reLayout();
        },
        reLayout: function(t) {
            this["_" + this.options.layoutMode + "Reset"](), this.layout(this.$filteredAtoms, t);
        },
        addItems: function(t, i) {
            var s = this._getAtoms(t);
            this.$allAtoms = this.$allAtoms.add(s), i && i(s);
        },
        insert: function(t, i) {
            this.element.append(t);
            var s = this;
            this.addItems(t, function(t) {
                var e = s._filter(t);
                s._addHideAppended(e), s._sort(), s.reLayout(), s._revealAppended(e, i);
            });
        },
        appended: function(t, i) {
            var s = this;
            this.addItems(t, function(t) {
                s._addHideAppended(t), s.layout(t), s._revealAppended(t, i);
            });
        },
        _addHideAppended: function(t) {
            this.$filteredAtoms = this.$filteredAtoms.add(t), t.addClass("no-transition"), this._isInserting = !0, 
            this.styleQueue.push({
                $el: t,
                style: this.options.hiddenStyle
            });
        },
        _revealAppended: function(t, i) {
            var s = this;
            setTimeout(function() {
                t.removeClass("no-transition"), s.styleQueue.push({
                    $el: t,
                    style: s.options.visibleStyle
                }), s._isInserting = !1, s._processStyleQueue(t, i);
            }, 10);
        },
        reloadItems: function() {
            this.$allAtoms = this._getAtoms(this.element.children());
        },
        remove: function(t, i) {
            this.$allAtoms = this.$allAtoms.not(t), this.$filteredAtoms = this.$filteredAtoms.not(t);
            var s = this, e = function() {
                t.remove(), i && i.call(s.element);
            };
            t.filter(":not(." + this.options.hiddenClass + ")").length ? (this.styleQueue.push({
                $el: t,
                style: this.options.hiddenStyle
            }), this._sort(), this.reLayout(e)) : e();
        },
        shuffle: function(t) {
            this.updateSortData(this.$allAtoms), this.options.sortBy = "random", this._sort(), 
            this.reLayout(t);
        },
        destroy: function() {
            var t = this.usingTransforms, i = this.options;
            this.$allAtoms.removeClass(i.hiddenClass + " " + i.itemClass).each(function() {
                var i = this.style;
                i.position = "", i.top = "", i.left = "", i.opacity = "", t && (i[l] = "");
            });
            var s = this.element[0].style;
            for (var e in this.originalStyle) s[e] = this.originalStyle[e];
            this.element.unbind(".isotope").undelegate("." + i.hiddenClass, "click").removeClass(i.containerClass).removeData("isotope"), 
            C.unbind(".isotope");
        },
        _getSegments: function(t) {
            var i, s = this.options.layoutMode, e = t ? "rowHeight" : "columnWidth", n = t ? "height" : "width", o = t ? "rows" : "cols", a = this.element[n](), h = this.options[s] && this.options[s][e] || this.$filteredAtoms["outer" + r(n)](!0) || a;
            i = Math.floor(a / h), i = Math.max(i, 1), this[s][o] = i, this[s][e] = h;
        },
        _checkIfSegmentsChanged: function(t) {
            var i = this.options.layoutMode, s = t ? "rows" : "cols", e = this[i][s];
            return this._getSegments(t), this[i][s] !== e;
        },
        _masonryReset: function() {
            this.masonry = {}, this._getSegments();
            var t = this.masonry.cols;
            for (this.masonry.colYs = []; t--; ) this.masonry.colYs.push(0);
        },
        _masonryLayout: function(t) {
            var s = this, e = s.masonry;
            t.each(function() {
                var t = i(this), n = Math.ceil(t.outerWidth(!0) / e.columnWidth);
                if (n = Math.min(n, e.cols), 1 === n) s._masonryPlaceBrick(t, e.colYs); else {
                    var o, r, a = e.cols + 1 - n, h = [];
                    for (r = 0; a > r; r++) o = e.colYs.slice(r, r + n), h[r] = Math.max.apply(Math, o);
                    s._masonryPlaceBrick(t, h);
                }
            });
        },
        _masonryPlaceBrick: function(t, i) {
            for (var s = Math.min.apply(Math, i), e = 0, n = 0, o = i.length; o > n; n++) if (i[n] === s) {
                e = n;
                break;
            }
            var r = this.masonry.columnWidth * e, a = s;
            this._pushPosition(t, r, a);
            var h = s + t.outerHeight(!0), l = this.masonry.cols + 1 - o;
            for (n = 0; l > n; n++) this.masonry.colYs[e + n] = h;
        },
        _masonryGetContainerSize: function() {
            var t = Math.max.apply(Math, this.masonry.colYs);
            return {
                height: t
            };
        },
        _masonryResizeChanged: function() {
            return this._checkIfSegmentsChanged();
        },
        _fitRowsReset: function() {
            this.fitRows = {
                x: 0,
                y: 0,
                height: 0
            };
        },
        _fitRowsLayout: function(t) {
            var s = this, e = this.element.width(), n = this.fitRows;
            t.each(function() {
                var t = i(this), o = t.outerWidth(!0), r = t.outerHeight(!0);
                0 !== n.x && o + n.x > e && (n.x = 0, n.y = n.height), s._pushPosition(t, n.x, n.y), 
                n.height = Math.max(n.y + r, n.height), n.x += o;
            });
        },
        _fitRowsGetContainerSize: function() {
            return {
                height: this.fitRows.height
            };
        },
        _fitRowsResizeChanged: function() {
            return !0;
        },
        _cellsByRowReset: function() {
            this.cellsByRow = {
                index: 0
            }, this._getSegments(), this._getSegments(!0);
        },
        _cellsByRowLayout: function(t) {
            var s = this, e = this.cellsByRow;
            t.each(function() {
                var t = i(this), n = e.index % e.cols, o = Math.floor(e.index / e.cols), r = (n + .5) * e.columnWidth - t.outerWidth(!0) / 2, a = (o + .5) * e.rowHeight - t.outerHeight(!0) / 2;
                s._pushPosition(t, r, a), e.index++;
            });
        },
        _cellsByRowGetContainerSize: function() {
            return {
                height: Math.ceil(this.$filteredAtoms.length / this.cellsByRow.cols) * this.cellsByRow.rowHeight + this.offset.top
            };
        },
        _cellsByRowResizeChanged: function() {
            return this._checkIfSegmentsChanged();
        },
        _straightDownReset: function() {
            this.straightDown = {
                y: 0
            };
        },
        _straightDownLayout: function(t) {
            var s = this;
            t.each(function() {
                var t = i(this);
                s._pushPosition(t, 0, s.straightDown.y), s.straightDown.y += t.outerHeight(!0);
            });
        },
        _straightDownGetContainerSize: function() {
            return {
                height: this.straightDown.y
            };
        },
        _straightDownResizeChanged: function() {
            return !0;
        },
        _masonryHorizontalReset: function() {
            this.masonryHorizontal = {}, this._getSegments(!0);
            var t = this.masonryHorizontal.rows;
            for (this.masonryHorizontal.rowXs = []; t--; ) this.masonryHorizontal.rowXs.push(0);
        },
        _masonryHorizontalLayout: function(t) {
            var s = this, e = s.masonryHorizontal;
            t.each(function() {
                var t = i(this), n = Math.ceil(t.outerHeight(!0) / e.rowHeight);
                if (n = Math.min(n, e.rows), 1 === n) s._masonryHorizontalPlaceBrick(t, e.rowXs); else {
                    var o, r, a = e.rows + 1 - n, h = [];
                    for (r = 0; a > r; r++) o = e.rowXs.slice(r, r + n), h[r] = Math.max.apply(Math, o);
                    s._masonryHorizontalPlaceBrick(t, h);
                }
            });
        },
        _masonryHorizontalPlaceBrick: function(t, i) {
            for (var s = Math.min.apply(Math, i), e = 0, n = 0, o = i.length; o > n; n++) if (i[n] === s) {
                e = n;
                break;
            }
            var r = s, a = this.masonryHorizontal.rowHeight * e;
            this._pushPosition(t, r, a);
            var h = s + t.outerWidth(!0), l = this.masonryHorizontal.rows + 1 - o;
            for (n = 0; l > n; n++) this.masonryHorizontal.rowXs[e + n] = h;
        },
        _masonryHorizontalGetContainerSize: function() {
            var t = Math.max.apply(Math, this.masonryHorizontal.rowXs);
            return {
                width: t
            };
        },
        _masonryHorizontalResizeChanged: function() {
            return this._checkIfSegmentsChanged(!0);
        },
        _fitColumnsReset: function() {
            this.fitColumns = {
                x: 0,
                y: 0,
                width: 0
            };
        },
        _fitColumnsLayout: function(t) {
            var s = this, e = this.element.height(), n = this.fitColumns;
            t.each(function() {
                var t = i(this), o = t.outerWidth(!0), r = t.outerHeight(!0);
                0 !== n.y && r + n.y > e && (n.x = n.width, n.y = 0), s._pushPosition(t, n.x, n.y), 
                n.width = Math.max(n.x + o, n.width), n.y += r;
            });
        },
        _fitColumnsGetContainerSize: function() {
            return {
                width: this.fitColumns.width
            };
        },
        _fitColumnsResizeChanged: function() {
            return !0;
        },
        _cellsByColumnReset: function() {
            this.cellsByColumn = {
                index: 0
            }, this._getSegments(), this._getSegments(!0);
        },
        _cellsByColumnLayout: function(t) {
            var s = this, e = this.cellsByColumn;
            t.each(function() {
                var t = i(this), n = Math.floor(e.index / e.rows), o = e.index % e.rows, r = (n + .5) * e.columnWidth - t.outerWidth(!0) / 2, a = (o + .5) * e.rowHeight - t.outerHeight(!0) / 2;
                s._pushPosition(t, r, a), e.index++;
            });
        },
        _cellsByColumnGetContainerSize: function() {
            return {
                width: Math.ceil(this.$filteredAtoms.length / this.cellsByColumn.rows) * this.cellsByColumn.columnWidth
            };
        },
        _cellsByColumnResizeChanged: function() {
            return this._checkIfSegmentsChanged(!0);
        },
        _straightAcrossReset: function() {
            this.straightAcross = {
                x: 0
            };
        },
        _straightAcrossLayout: function(t) {
            var s = this;
            t.each(function() {
                var t = i(this);
                s._pushPosition(t, s.straightAcross.x, 0), s.straightAcross.x += t.outerWidth(!0);
            });
        },
        _straightAcrossGetContainerSize: function() {
            return {
                width: this.straightAcross.x
            };
        },
        _straightAcrossResizeChanged: function() {
            return !0;
        }
    }, i.fn.imagesLoaded = function(t) {
        function s() {
            t.call(n, o);
        }
        function e(t) {
            var n = t.target;
            n.src !== a && -1 === i.inArray(n, h) && (h.push(n), --r <= 0 && (setTimeout(s), 
            o.unbind(".imagesLoaded", e)));
        }
        var n = this, o = n.find("img").add(n.filter("img")), r = o.length, a = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==", h = [];
        return r || s(), o.bind("load.imagesLoaded error.imagesLoaded", e).each(function() {
            var t = this.src;
            this.src = a, this.src = t;
        }), n;
    };
    var z = function(i) {
        t.console && t.console.error(i);
    };
    i.fn.isotope = function(t, s) {
        if ("string" == typeof t) {
            var e = Array.prototype.slice.call(arguments, 1);
            this.each(function() {
                var s = i.data(this, "isotope");
                return s ? i.isFunction(s[t]) && "_" !== t.charAt(0) ? void s[t].apply(s, e) : void z("no such method '" + t + "' for isotope instance") : void z("cannot call methods on isotope prior to initialization; attempted to call method '" + t + "'");
            });
        } else this.each(function() {
            var e = i.data(this, "isotope");
            e ? (e.option(t), e._init(s)) : i.data(this, "isotope", new i.Isotope(t, this, s));
        });
        return this;
    };
}(window, jQuery);

(function() {
    var method;
    var noop = function() {};
    var methods = [ "assert", "clear", "count", "debug", "dir", "dirxml", "error", "exception", "group", "groupCollapsed", "groupEnd", "info", "log", "markTimeline", "profile", "profileEnd", "table", "time", "timeEnd", "timeStamp", "trace", "warn" ];
    var length = methods.length;
    var console = window.console = window.console || {};
    while (length--) {
        method = methods[length];
        if (!console[method]) {
            console[method] = noop;
        }
    }
})();

(function($) {
    var CLOSE_EVENT = "Close", BEFORE_APPEND_EVENT = "BeforeAppend", MARKUP_PARSE_EVENT = "MarkupParse", OPEN_EVENT = "Open", CHANGE_EVENT = "Change", NS = "mfp", EVENT_NS = "." + NS, READY_CLASS = "mfp-ready", REMOVING_CLASS = "mfp-removing", PREVENT_CLOSE_CLASS = "mfp-prevent-close";
    var mfp, MagnificPopup = function() {}, _isJQ = !!window.jQuery, _prevStatus, _window = $(window), _body, _document, _prevContentType, _wrapClasses, _currPopupType;
    var _mfpOn = function(name, f) {
        mfp.ev.on(NS + name + EVENT_NS, f);
    }, _getEl = function(className, appendTo, html, raw) {
        var el = document.createElement("div");
        el.className = "mfp-" + className;
        if (html) {
            el.innerHTML = html;
        }
        if (!raw) {
            el = $(el);
            if (appendTo) {
                el.appendTo(appendTo);
            }
        } else if (appendTo) {
            appendTo.appendChild(el);
        }
        return el;
    }, _mfpTrigger = function(e, data) {
        mfp.ev.triggerHandler(NS + e, data);
        if (mfp.st.callbacks) {
            e = e.charAt(0).toLowerCase() + e.slice(1);
            if (mfp.st.callbacks[e]) {
                mfp.st.callbacks[e].apply(mfp, $.isArray(data) ? data : [ data ]);
            }
        }
    }, _setFocus = function() {
        (mfp.st.focus ? mfp.content.find(mfp.st.focus).eq(0) : mfp.wrap).focus();
    }, _getCloseBtn = function(type) {
        if (type !== _currPopupType || !mfp.currTemplate.closeBtn) {
            mfp.currTemplate.closeBtn = $(mfp.st.closeMarkup.replace("%title%", mfp.st.tClose));
            _currPopupType = type;
        }
        return mfp.currTemplate.closeBtn;
    }, _checkInstance = function() {
        if (!$.magnificPopup.instance) {
            mfp = new MagnificPopup();
            mfp.init();
            $.magnificPopup.instance = mfp;
        }
    }, _checkIfClose = function(target) {
        if ($(target).hasClass(PREVENT_CLOSE_CLASS)) {
            return;
        }
        var closeOnContent = mfp.st.closeOnContentClick;
        var closeOnBg = mfp.st.closeOnBgClick;
        if (closeOnContent && closeOnBg) {
            return true;
        } else {
            if (!mfp.content || $(target).hasClass("mfp-close") || mfp.preloader && target === mfp.preloader[0]) {
                return true;
            }
            if (target !== mfp.content[0] && !$.contains(mfp.content[0], target)) {
                if (closeOnBg) {
                    return true;
                }
            } else if (closeOnContent) {
                return true;
            }
        }
        return false;
    };
    MagnificPopup.prototype = {
        constructor: MagnificPopup,
        init: function() {
            var appVersion = navigator.appVersion;
            mfp.isIE7 = appVersion.indexOf("MSIE 7.") !== -1;
            mfp.isIE8 = appVersion.indexOf("MSIE 8.") !== -1, mfp.isLowIE = mfp.isIE7 || mfp.isIE8;
            mfp.isAndroid = /android/gi.test(appVersion);
            mfp.isIOS = /iphone|ipad|ipod/gi.test(appVersion);
            mfp.probablyMobile = mfp.isAndroid || mfp.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent);
            _body = $(document.body);
            _document = $(document);
            mfp.popupsCache = {};
        },
        open: function(data) {
            var i;
            if (data.isObj === false) {
                mfp.items = data.items.toArray();
            } else {
                mfp.items = $.isArray(data.items) ? data.items : [ data.items ];
            }
            if (mfp.isOpen) {
                mfp.updateItemHTML();
                return;
            }
            mfp.types = [];
            _wrapClasses = "";
            mfp.ev = data.mainEl || _document;
            if (data.isObj) {
                mfp.index = data.index || 0;
            } else {
                mfp.index = 0;
                var items = data.items, item;
                for (i = 0; i < items.length; i++) {
                    item = items[i];
                    if (item.parsed) {
                        item = item.el[0];
                    }
                    if (item === data.el[0]) {
                        mfp.index = i;
                        break;
                    }
                }
            }
            if (data.key) {
                if (!mfp.popupsCache[data.key]) {
                    mfp.popupsCache[data.key] = {};
                }
                mfp.currTemplate = mfp.popupsCache[data.key];
            } else {
                mfp.currTemplate = {};
            }
            mfp.st = $.extend(true, {}, $.magnificPopup.defaults, data);
            mfp.fixedContentPos = mfp.st.fixedContentPos === "auto" ? !mfp.probablyMobile : mfp.st.fixedContentPos;
            if (!mfp.bgOverlay) {
                mfp.bgOverlay = _getEl("bg").on("click" + EVENT_NS, function() {
                    mfp.close();
                });
                mfp.wrap = _getEl("wrap").attr("tabindex", -1).on("click" + EVENT_NS, function(e) {
                    if (_checkIfClose(e.target)) {
                        mfp.close();
                    }
                });
                mfp.container = _getEl("container", mfp.wrap);
            }
            mfp.contentContainer = _getEl("content");
            if (mfp.st.preloader) {
                mfp.preloader = _getEl("preloader", mfp.container, mfp.st.tLoading);
            }
            var modules = $.magnificPopup.modules;
            for (i = 0; i < modules.length; i++) {
                var n = modules[i];
                n = n.charAt(0).toUpperCase() + n.slice(1);
                mfp["init" + n].call(mfp);
            }
            _mfpTrigger("BeforeOpen");
            if (!mfp.st.closeBtnInside) {
                mfp.wrap.append(_getCloseBtn());
            } else {
                _mfpOn(MARKUP_PARSE_EVENT, function(e, template, values, item) {
                    values.close_replaceWith = _getCloseBtn(item.type);
                });
                _wrapClasses += " mfp-close-btn-in";
            }
            if (mfp.st.alignTop) {
                _wrapClasses += " mfp-align-top";
            }
            if (mfp.fixedContentPos) {
                mfp.wrap.css({
                    overflow: mfp.st.overflowY,
                    overflowX: "hidden",
                    overflowY: mfp.st.overflowY
                });
            } else {
                mfp.wrap.css({
                    top: _window.scrollTop(),
                    position: "absolute"
                });
            }
            if (mfp.st.fixedBgPos === false || mfp.st.fixedBgPos === "auto" && !mfp.fixedContentPos) {
                mfp.bgOverlay.css({
                    height: _document.height(),
                    position: "absolute"
                });
            }
            _document.on("keyup" + EVENT_NS, function(e) {
                if (e.keyCode === 27) {
                    mfp.close();
                }
            });
            _window.on("resize" + EVENT_NS, function() {
                mfp.updateSize();
            });
            if (!mfp.st.closeOnContentClick) {
                _wrapClasses += " mfp-auto-cursor";
            }
            if (_wrapClasses) mfp.wrap.addClass(_wrapClasses);
            var windowHeight = mfp.wH = _window.height();
            var bodyStyles = {};
            if (mfp.fixedContentPos) {
                var s = mfp._getScrollbarSize();
                if (s) {
                    bodyStyles.paddingRight = s;
                }
            }
            if (mfp.fixedContentPos) {
                if (!mfp.isIE7) {
                    bodyStyles.overflow = "hidden";
                } else {
                    $("body, html").css("overflow", "hidden");
                }
            }
            var classesToadd = mfp.st.mainClass;
            if (mfp.isIE7) {
                classesToadd += " mfp-ie7";
            }
            if (classesToadd) {
                mfp._addClassToMFP(classesToadd);
            }
            mfp.updateItemHTML();
            _mfpTrigger("BuildControls");
            _body.css(bodyStyles);
            mfp.bgOverlay.add(mfp.wrap).prependTo(document.body);
            mfp._lastFocusedEl = document.activeElement;
            setTimeout(function() {
                if (mfp.content) {
                    mfp._addClassToMFP(READY_CLASS);
                    _setFocus();
                } else {
                    mfp.bgOverlay.addClass(READY_CLASS);
                }
                _document.on("focusin" + EVENT_NS, function(e) {
                    if (e.target !== mfp.wrap[0] && !$.contains(mfp.wrap[0], e.target)) {
                        _setFocus();
                        return false;
                    }
                });
            }, 16);
            mfp.isOpen = true;
            mfp.updateSize(windowHeight);
            _mfpTrigger(OPEN_EVENT);
        },
        close: function() {
            if (!mfp.isOpen) return;
            mfp.isOpen = false;
            if (mfp.st.removalDelay && !mfp.isLowIE) {
                mfp._addClassToMFP(REMOVING_CLASS);
                setTimeout(function() {
                    mfp._close();
                }, mfp.st.removalDelay);
            } else {
                mfp._close();
            }
        },
        _close: function() {
            _mfpTrigger(CLOSE_EVENT);
            var classesToRemove = REMOVING_CLASS + " " + READY_CLASS + " ";
            mfp.bgOverlay.detach();
            mfp.wrap.detach();
            mfp.container.empty();
            if (mfp.st.mainClass) {
                classesToRemove += mfp.st.mainClass + " ";
            }
            mfp._removeClassFromMFP(classesToRemove);
            if (mfp.fixedContentPos) {
                var bodyStyles = {
                    paddingRight: 0
                };
                if (mfp.isIE7) {
                    $("body, html").css("overflow", "auto");
                } else {
                    bodyStyles.overflow = "visible";
                }
                _body.css(bodyStyles);
            }
            _document.off("keyup" + EVENT_NS + " focusin" + EVENT_NS);
            mfp.ev.off(EVENT_NS);
            mfp.wrap.attr("class", "mfp-wrap").removeAttr("style");
            mfp.bgOverlay.attr("class", "mfp-bg");
            mfp.container.attr("class", "mfp-container");
            if (!mfp.st.closeBtnInside || mfp.currTemplate[mfp.currItem.type] === true) {
                if (mfp.currTemplate.closeBtn) mfp.currTemplate.closeBtn.detach();
            }
            if (mfp._lastFocusedEl) {
                $(mfp._lastFocusedEl).focus();
            }
            mfp.currItem = null;
            mfp.content = null;
            mfp.currTemplate = null;
            mfp.prevHeight = 0;
        },
        updateSize: function(winHeight) {
            if (mfp.isIOS) {
                var zoomLevel = document.documentElement.clientWidth / window.innerWidth;
                var height = window.innerHeight * zoomLevel;
                mfp.wrap.css("height", height);
                mfp.wH = height;
            } else {
                mfp.wH = winHeight || _window.height();
            }
            _mfpTrigger("Resize");
        },
        updateItemHTML: function() {
            var item = mfp.items[mfp.index];
            mfp.contentContainer.detach();
            if (mfp.content) mfp.content.detach();
            if (!item.parsed) {
                item = mfp.parseEl(mfp.index);
            }
            var type = item.type;
            _mfpTrigger("BeforeChange", [ mfp.currItem ? mfp.currItem.type : "", type ]);
            mfp.currItem = item;
            if (!mfp.currTemplate[type]) {
                var markup = mfp.st[type] ? mfp.st[type].markup : false;
                _mfpTrigger("FirstMarkupParse", markup);
                if (markup) {
                    mfp.currTemplate[type] = $(markup);
                } else {
                    mfp.currTemplate[type] = true;
                }
            }
            if (_prevContentType && _prevContentType !== item.type) {
                mfp.container.removeClass("mfp-" + _prevContentType + "-holder");
            }
            var newContent = mfp["get" + type.charAt(0).toUpperCase() + type.slice(1)](item, mfp.currTemplate[type]);
            mfp.appendContent(newContent, type);
            item.preloaded = true;
            _mfpTrigger(CHANGE_EVENT, item);
            _prevContentType = item.type;
            mfp.container.prepend(mfp.contentContainer);
            _mfpTrigger("AfterChange");
        },
        appendContent: function(newContent, type) {
            mfp.content = newContent;
            if (newContent) {
                if (mfp.st.closeBtnInside && mfp.currTemplate[type] === true) {
                    if (!mfp.content.find(".mfp-close").length) {
                        mfp.content.append(_getCloseBtn());
                    }
                } else {
                    mfp.content = newContent;
                }
            } else {
                mfp.content = "";
            }
            _mfpTrigger(BEFORE_APPEND_EVENT);
            mfp.container.addClass("mfp-" + type + "-holder");
            mfp.contentContainer.append(mfp.content);
        },
        parseEl: function(index) {
            var item = mfp.items[index], type = item.type;
            if (item.tagName) {
                item = {
                    el: $(item)
                };
            } else {
                item = {
                    data: item,
                    src: item.src
                };
            }
            if (item.el) {
                var types = mfp.types;
                for (var i = 0; i < types.length; i++) {
                    if (item.el.hasClass("mfp-" + types[i])) {
                        type = types[i];
                        break;
                    }
                }
                item.src = item.el.attr("data-mfp-src");
                if (!item.src) {
                    item.src = item.el.attr("href");
                }
            }
            item.type = type || mfp.st.type || "inline";
            item.index = index;
            item.parsed = true;
            mfp.items[index] = item;
            _mfpTrigger("ElementParse", item);
            return mfp.items[index];
        },
        addGroup: function(el, options) {
            var eHandler = function(e) {
                e.mfpEl = this;
                mfp._openClick(e, el, options);
            };
            if (!options) {
                options = {};
            }
            var eName = "click.magnificPopup";
            options.mainEl = el;
            if (options.items) {
                options.isObj = true;
                el.off(eName).on(eName, eHandler);
            } else {
                options.isObj = false;
                if (options.delegate) {
                    el.off(eName).on(eName, options.delegate, eHandler);
                } else {
                    options.items = el;
                    el.off(eName).on(eName, eHandler);
                }
            }
        },
        _openClick: function(e, el, options) {
            var midClick = options.midClick !== undefined ? options.midClick : $.magnificPopup.defaults.midClick;
            if (midClick || e.which !== 2) {
                var disableOn = options.disableOn !== undefined ? options.disableOn : $.magnificPopup.defaults.disableOn;
                if (disableOn) {
                    if ($.isFunction(disableOn)) {
                        if (!disableOn.call(mfp)) {
                            return true;
                        }
                    } else {
                        if (_window.width() < disableOn) {
                            return true;
                        }
                    }
                }
                if (e.type) e.preventDefault();
                options.el = $(e.mfpEl);
                if (options.delegate) {
                    options.items = el.find(options.delegate);
                }
                mfp.open(options);
            }
        },
        updateStatus: function(status, text) {
            if (mfp.preloader) {
                if (_prevStatus !== status) {
                    mfp.container.removeClass("mfp-s-" + _prevStatus);
                }
                if (!text && status === "loading") {
                    text = mfp.st.tLoading;
                }
                var data = {
                    status: status,
                    text: text
                };
                _mfpTrigger("UpdateStatus", data);
                status = data.status;
                text = data.text;
                mfp.preloader.html(text);
                mfp.preloader.find("a").click(function(e) {
                    e.stopImmediatePropagation();
                });
                mfp.container.addClass("mfp-s-" + status);
                _prevStatus = status;
            }
        },
        _addClassToMFP: function(cName) {
            mfp.bgOverlay.addClass(cName);
            mfp.wrap.addClass(cName);
        },
        _removeClassFromMFP: function(cName) {
            this.bgOverlay.removeClass(cName);
            mfp.wrap.removeClass(cName);
        },
        _hasScrollBar: function(winHeight) {
            if (document.body.clientHeight > (winHeight || _window.height())) {
                return true;
            }
            return false;
        },
        _parseMarkup: function(template, values, item) {
            var arr;
            if (item.data) {
                values = $.extend(item.data, values);
            }
            _mfpTrigger(MARKUP_PARSE_EVENT, [ template, values, item ]);
            $.each(values, function(key, value) {
                if (value === undefined || value === false) {
                    return true;
                }
                arr = key.split("_");
                if (arr.length > 1) {
                    var el = template.find(EVENT_NS + "-" + arr[0]);
                    if (el.length > 0) {
                        var attr = arr[1];
                        if (attr === "replaceWith") {
                            if (el[0] !== value[0]) {
                                el.replaceWith(value);
                            }
                        } else if (attr === "img") {
                            if (el.is("img")) {
                                el.attr("src", value);
                            } else {
                                el.replaceWith('<img src="' + value + '" class="' + el.attr("class") + '" />');
                            }
                        } else {
                            el.attr(arr[1], value);
                        }
                    }
                } else {
                    template.find(EVENT_NS + "-" + key).html(value);
                }
            });
        },
        _getScrollbarSize: function() {
            if (mfp.scrollbarSize === undefined) {
                var scrollDiv = document.createElement("div");
                scrollDiv.id = "mfp-sbm";
                scrollDiv.style.cssText = "width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;";
                document.body.appendChild(scrollDiv);
                mfp.scrollbarSize = scrollDiv.offsetWidth - scrollDiv.clientWidth;
                document.body.removeChild(scrollDiv);
            }
            return mfp.scrollbarSize;
        }
    };
    $.magnificPopup = {
        instance: null,
        proto: MagnificPopup.prototype,
        modules: [],
        open: function(options, index) {
            _checkInstance();
            if (!options) options = {};
            options.isObj = true;
            options.index = index || 0;
            return this.instance.open(options);
        },
        close: function() {
            return $.magnificPopup.instance.close();
        },
        registerModule: function(name, module) {
            if (module.options) {
                $.magnificPopup.defaults[name] = module.options;
            }
            $.extend(this.proto, module.proto);
            this.modules.push(name);
        },
        defaults: {
            disableOn: 0,
            key: null,
            midClick: false,
            mainClass: "",
            preloader: true,
            focus: "",
            closeOnContentClick: false,
            closeOnBgClick: true,
            closeBtnInside: true,
            alignTop: false,
            removalDelay: 0,
            fixedContentPos: "auto",
            fixedBgPos: "auto",
            overflowY: "auto",
            closeMarkup: '<button title="%title%" type="button" class="mfp-close">&times;</button>',
            tClose: "Close (Esc)",
            tLoading: "Loading..."
        }
    };
    $.fn.magnificPopup = function(options) {
        _checkInstance();
        var jqEl = $(this);
        if (typeof options === "string") {
            if (options === "open") {
                var items, itemOpts = _isJQ ? jqEl.data("magnificPopup") : jqEl[0].magnificPopup, index = parseInt(arguments[1], 10) || 0;
                if (itemOpts.items) {
                    items = itemOpts.items[index];
                } else {
                    items = jqEl;
                    if (itemOpts.delegate) {
                        items = items.find(itemOpts.delegate);
                    }
                    items = items.eq(index);
                }
                mfp._openClick({
                    mfpEl: items
                }, jqEl, itemOpts);
            } else {
                if (mfp.isOpen) mfp[options].apply(mfp, Array.prototype.slice.call(arguments, 1));
            }
        } else {
            if (_isJQ) {
                jqEl.data("magnificPopup", options);
            } else {
                jqEl[0].magnificPopup = options;
            }
            mfp.addGroup(jqEl, options);
        }
        return jqEl;
    };
    var INLINE_NS = "inline", _hiddenClass, _inlinePlaceholder, _lastInlineElement, _putInlineElementsBack = function() {
        if (_lastInlineElement) {
            _inlinePlaceholder.after(_lastInlineElement.addClass(_hiddenClass)).detach();
            _lastInlineElement = null;
        }
    };
    $.magnificPopup.registerModule(INLINE_NS, {
        options: {
            hiddenClass: "hide",
            markup: "",
            tNotFound: "Content not found"
        },
        proto: {
            initInline: function() {
                mfp.types.push(INLINE_NS);
                _mfpOn(CLOSE_EVENT + "." + INLINE_NS, function() {
                    _putInlineElementsBack();
                });
            },
            getInline: function(item, template) {
                _putInlineElementsBack();
                if (item.src) {
                    var inlineSt = mfp.st.inline, el = $(item.src);
                    if (el.length) {
                        if (el[0].parentNode !== null) {
                            if (!_inlinePlaceholder) {
                                _hiddenClass = inlineSt.hiddenClass;
                                _inlinePlaceholder = _getEl(_hiddenClass);
                                _hiddenClass = "mfp-" + _hiddenClass;
                            }
                            _lastInlineElement = el.after(_inlinePlaceholder).detach().removeClass(_hiddenClass);
                        }
                        mfp.updateStatus("ready");
                    } else {
                        mfp.updateStatus("error", inlineSt.tNotFound);
                        el = $("<div>");
                    }
                    item.inlineElement = el;
                    return el;
                }
                mfp.updateStatus("ready");
                mfp._parseMarkup(template, {}, item);
                return template;
            }
        }
    });
    var AJAX_NS = "ajax", _ajaxCur, _removeAjaxCursor = function() {
        if (_ajaxCur) {
            _body.removeClass(_ajaxCur);
        }
    };
    $.magnificPopup.registerModule(AJAX_NS, {
        options: {
            settings: null,
            cursor: "mfp-ajax-cur",
            tError: '<a href="%url%">The content</a> could not be loaded.'
        },
        proto: {
            initAjax: function() {
                mfp.types.push(AJAX_NS);
                _ajaxCur = mfp.st.ajax.cursor;
                _mfpOn(CLOSE_EVENT + "." + AJAX_NS, function() {
                    _removeAjaxCursor();
                    if (mfp.req) {
                        mfp.req.abort();
                    }
                });
            },
            getAjax: function(item) {
                if (_ajaxCur) _body.addClass(_ajaxCur);
                mfp.updateStatus("loading");
                var opts = $.extend({
                    url: item.src,
                    success: function(data, textStatus, jqXHR) {
                        _mfpTrigger("ParseAjax", jqXHR);
                        mfp.appendContent($(jqXHR.responseText), AJAX_NS);
                        item.finished = true;
                        _removeAjaxCursor();
                        _setFocus();
                        setTimeout(function() {
                            mfp.wrap.addClass(READY_CLASS);
                        }, 16);
                        mfp.updateStatus("ready");
                    },
                    error: function() {
                        _removeAjaxCursor();
                        item.finished = item.loadError = true;
                        mfp.updateStatus("error", mfp.st.ajax.tError.replace("%url%", item.src));
                    }
                }, mfp.st.ajax.settings);
                mfp.req = $.ajax(opts);
                return "";
            }
        }
    });
    var _imgInterval, _getTitle = function(item) {
        if (item.data && item.data.title !== undefined) return item.data.title;
        var src = mfp.st.image.titleSrc;
        if (src) {
            if ($.isFunction(src)) {
                return src.call(mfp, item);
            } else if (item.el) {
                return item.el.attr(src) || "";
            }
        }
        return "";
    };
    $.magnificPopup.registerModule("image", {
        options: {
            markup: '<div class="mfp-figure">' + '<div class="mfp-close"></div>' + '<div class="mfp-img"></div>' + '<div class="mfp-bottom-bar">' + '<div class="mfp-title"></div>' + '<div class="mfp-counter"></div>' + "</div>" + "</div>",
            cursor: "mfp-zoom-out-cur",
            titleSrc: "title",
            verticalFit: true,
            tError: '<a href="%url%">The image</a> could not be loaded.'
        },
        proto: {
            initImage: function() {
                var imgSt = mfp.st.image, ns = ".image";
                mfp.types.push("image");
                _mfpOn(OPEN_EVENT + ns, function() {
                    if (mfp.currItem.type === "image" && imgSt.cursor) {
                        _body.addClass(imgSt.cursor);
                    }
                });
                _mfpOn(CLOSE_EVENT + ns, function() {
                    if (imgSt.cursor) {
                        _body.removeClass(imgSt.cursor);
                    }
                    _window.off("resize" + EVENT_NS);
                });
                _mfpOn("Resize" + ns, mfp.resizeImage);
                if (mfp.isLowIE) {
                    _mfpOn("AfterChange", mfp.resizeImage);
                }
            },
            resizeImage: function() {
                var item = mfp.currItem;
                if (!item.img) return;
                if (mfp.st.image.verticalFit) {
                    var decr = 0;
                    if (mfp.isLowIE) {
                        decr = parseInt(item.img.css("padding-top"), 10) + parseInt(item.img.css("padding-bottom"), 10);
                    }
                    item.img.css("max-height", mfp.wH - decr);
                }
            },
            _onImageHasSize: function(item) {
                if (item.img) {
                    item.hasSize = true;
                    if (_imgInterval) {
                        clearInterval(_imgInterval);
                    }
                    item.isCheckingImgSize = false;
                    _mfpTrigger("ImageHasSize", item);
                    if (item.imgHidden) {
                        if (mfp.content) mfp.content.removeClass("mfp-loading");
                        item.imgHidden = false;
                    }
                }
            },
            findImageSize: function(item) {
                var counter = 0, img = item.img[0], mfpSetInterval = function(delay) {
                    if (_imgInterval) {
                        clearInterval(_imgInterval);
                    }
                    _imgInterval = setInterval(function() {
                        if (img.naturalWidth > 0) {
                            mfp._onImageHasSize(item);
                            return;
                        }
                        if (counter > 200) {
                            clearInterval(_imgInterval);
                        }
                        counter++;
                        if (counter === 3) {
                            mfpSetInterval(10);
                        } else if (counter === 40) {
                            mfpSetInterval(50);
                        } else if (counter === 100) {
                            mfpSetInterval(500);
                        }
                    }, delay);
                };
                mfpSetInterval(1);
            },
            getImage: function(item, template) {
                var guard = 0, onLoadComplete = function() {
                    if (item) {
                        if (item.img[0].complete) {
                            item.img.off(".mfploader");
                            if (item === mfp.currItem) {
                                mfp._onImageHasSize(item);
                                mfp.updateStatus("ready");
                            }
                            item.hasSize = true;
                            item.loaded = true;
                        } else {
                            guard++;
                            if (guard < 200) {
                                setTimeout(onLoadComplete, 100);
                            } else {
                                onLoadError();
                            }
                        }
                    }
                }, onLoadError = function() {
                    if (item) {
                        item.img.off(".mfploader");
                        if (item === mfp.currItem) {
                            mfp._onImageHasSize(item);
                            mfp.updateStatus("error", imgSt.tError.replace("%url%", item.src));
                        }
                        item.hasSize = true;
                        item.loaded = true;
                        item.loadError = true;
                    }
                }, imgSt = mfp.st.image;
                var el = template.find(".mfp-img");
                if (el.length) {
                    var img = new Image();
                    img.className = "mfp-img";
                    item.img = $(img).on("load.mfploader", onLoadComplete).on("error.mfploader", onLoadError);
                    img.src = item.src;
                    if (el.is("img")) {
                        item.img = item.img.clone();
                    }
                }
                mfp._parseMarkup(template, {
                    title: _getTitle(item),
                    img_replaceWith: item.img
                }, item);
                mfp.resizeImage();
                if (item.hasSize) {
                    if (_imgInterval) clearInterval(_imgInterval);
                    if (item.loadError) {
                        template.addClass("mfp-loading");
                        mfp.updateStatus("error", imgSt.tError.replace("%url%", item.src));
                    } else {
                        template.removeClass("mfp-loading");
                        mfp.updateStatus("ready");
                    }
                    return template;
                }
                mfp.updateStatus("loading");
                item.loading = true;
                if (!item.hasSize) {
                    item.imgHidden = true;
                    template.addClass("mfp-loading");
                    mfp.findImageSize(item);
                }
                return template;
            }
        }
    });
    var IFRAME_NS = "iframe", _emptyPage = "//about:blank", _fixIframeBugs = function(isShowing) {
        if (mfp.currTemplate[IFRAME_NS]) {
            var el = mfp.currTemplate[IFRAME_NS].find("iframe");
            if (el.length) {
                if (!isShowing) {
                    el[0].src = _emptyPage;
                }
                if (mfp.isIE8) {
                    el.css("display", isShowing ? "block" : "none");
                }
            }
        }
    };
    $.magnificPopup.registerModule(IFRAME_NS, {
        options: {
            markup: '<div class="mfp-iframe-scaler">' + '<div class="mfp-close"></div>' + '<iframe class="mfp-iframe" src="//about:blank" frameborder="0" allowfullscreen></iframe>' + "</div>",
            srcAction: "iframe_src",
            patterns: {
                youtube: {
                    index: "youtube.com",
                    id: "v=",
                    src: "//www.youtube.com/embed/%id%?autoplay=1"
                },
                vimeo: {
                    index: "vimeo.com/",
                    id: "/",
                    src: "//player.vimeo.com/video/%id%?autoplay=1"
                },
                gmaps: {
                    index: "//maps.google.",
                    src: "%id%&output=embed"
                }
            }
        },
        proto: {
            initIframe: function() {
                mfp.types.push(IFRAME_NS);
                _mfpOn("BeforeChange", function(e, prevType, newType) {
                    if (prevType !== newType) {
                        if (prevType === IFRAME_NS) {
                            _fixIframeBugs();
                        } else if (newType === IFRAME_NS) {
                            _fixIframeBugs(true);
                        }
                    }
                });
                _mfpOn(CLOSE_EVENT + "." + IFRAME_NS, function() {
                    _fixIframeBugs();
                });
            },
            getIframe: function(item, template) {
                var embedSrc = item.src;
                var iframeSt = mfp.st.iframe;
                $.each(iframeSt.patterns, function() {
                    if (embedSrc.indexOf(this.index) > -1) {
                        if (this.id) {
                            if (typeof this.id === "string") {
                                embedSrc = embedSrc.substr(embedSrc.lastIndexOf(this.id) + this.id.length, embedSrc.length);
                            } else {
                                embedSrc = this.id.call(this, embedSrc);
                            }
                        }
                        embedSrc = this.src.replace("%id%", embedSrc);
                        return false;
                    }
                });
                var dataObj = {};
                if (iframeSt.srcAction) {
                    dataObj[iframeSt.srcAction] = embedSrc;
                }
                mfp._parseMarkup(template, dataObj, item);
                mfp.updateStatus("ready");
                return template;
            }
        }
    });
    var _getLoopedId = function(index) {
        var numSlides = mfp.items.length;
        if (index > numSlides - 1) {
            return index - numSlides;
        } else if (index < 0) {
            return numSlides + index;
        }
        return index;
    }, _replaceCurrTotal = function(text, curr, total) {
        return text.replace("%curr%", curr + 1).replace("%total%", total);
    };
    $.magnificPopup.registerModule("gallery", {
        options: {
            enabled: false,
            arrowMarkup: '<button title="%title%" type="button" class="mfp-arrow mfp-arrow-%dir%"></button>',
            preload: [ 0, 2 ],
            navigateByImgClick: true,
            arrows: true,
            tPrev: "Previous (Left arrow key)",
            tNext: "Next (Right arrow key)",
            tCounter: "%curr% of %total%"
        },
        proto: {
            initGallery: function() {
                var gSt = mfp.st.gallery, ns = ".mfp-gallery", supportsFastClick = Boolean($.fn.mfpFastClick);
                mfp.direction = true;
                if (!gSt || !gSt.enabled) return false;
                _wrapClasses += " mfp-gallery";
                _mfpOn(OPEN_EVENT + ns, function() {
                    if (gSt.navigateByImgClick) {
                        mfp.wrap.on("click" + ns, ".mfp-img", function() {
                            if (mfp.items.length > 1) {
                                mfp.next();
                                return false;
                            }
                        });
                    }
                    _document.on("keydown" + ns, function(e) {
                        if (e.keyCode === 37) {
                            mfp.prev();
                        } else if (e.keyCode === 39) {
                            mfp.next();
                        }
                    });
                });
                _mfpOn("UpdateStatus" + ns, function(e, data) {
                    if (data.text) {
                        data.text = _replaceCurrTotal(data.text, mfp.currItem.index, mfp.items.length);
                    }
                });
                _mfpOn(MARKUP_PARSE_EVENT + ns, function(e, element, values, item) {
                    var l = mfp.items.length;
                    values.counter = l > 1 ? _replaceCurrTotal(gSt.tCounter, item.index, l) : "";
                });
                _mfpOn("BuildControls" + ns, function() {
                    if (mfp.items.length > 1 && gSt.arrows && !mfp.arrowLeft) {
                        var markup = gSt.arrowMarkup, arrowLeft = mfp.arrowLeft = $(markup.replace("%title%", gSt.tPrev).replace("%dir%", "left")).addClass(PREVENT_CLOSE_CLASS), arrowRight = mfp.arrowRight = $(markup.replace("%title%", gSt.tNext).replace("%dir%", "right")).addClass(PREVENT_CLOSE_CLASS);
                        var eName = supportsFastClick ? "mfpFastClick" : "click";
                        arrowLeft[eName](function() {
                            mfp.prev();
                        });
                        arrowRight[eName](function() {
                            mfp.next();
                        });
                        if (mfp.isIE7) {
                            _getEl("b", arrowLeft[0], false, true);
                            _getEl("a", arrowLeft[0], false, true);
                            _getEl("b", arrowRight[0], false, true);
                            _getEl("a", arrowRight[0], false, true);
                        }
                        mfp.container.append(arrowLeft.add(arrowRight));
                    }
                });
                _mfpOn(CHANGE_EVENT + ns, function() {
                    if (mfp._preloadTimeout) clearTimeout(mfp._preloadTimeout);
                    mfp._preloadTimeout = setTimeout(function() {
                        mfp.preloadNearbyImages();
                        mfp._preloadTimeout = null;
                    }, 16);
                });
                _mfpOn(CLOSE_EVENT + ns, function() {
                    _document.off(ns);
                    mfp.wrap.off("click" + ns);
                    if (mfp.arrowLeft && supportsFastClick) {
                        mfp.arrowLeft.add(mfp.arrowRight).destroyMfpFastClick();
                    }
                    mfp.arrowRight = mfp.arrowLeft = null;
                });
            },
            next: function() {
                mfp.direction = true;
                mfp.index = _getLoopedId(mfp.index + 1);
                mfp.updateItemHTML();
            },
            prev: function() {
                mfp.direction = false;
                mfp.index = _getLoopedId(mfp.index - 1);
                mfp.updateItemHTML();
            },
            goTo: function(newIndex) {
                mfp.direction = newIndex >= mfp.index;
                mfp.index = newIndex;
                mfp.updateItemHTML();
            },
            preloadNearbyImages: function() {
                var p = mfp.st.gallery.preload, preloadBefore = Math.min(p[0], mfp.items.length), preloadAfter = Math.min(p[1], mfp.items.length), i;
                for (i = 1; i <= (mfp.direction ? preloadAfter : preloadBefore); i++) {
                    mfp._preloadItem(mfp.index + i);
                }
                for (i = 1; i <= (mfp.direction ? preloadBefore : preloadAfter); i++) {
                    mfp._preloadItem(mfp.index - i);
                }
            },
            _preloadItem: function(index) {
                index = _getLoopedId(index);
                if (mfp.items[index].preloaded) {
                    return;
                }
                var item = mfp.items[index];
                if (!item.parsed) {
                    item = mfp.parseEl(index);
                }
                _mfpTrigger("LazyLoad", item);
                if (item.type === "image") {
                    item.img = $('<img class="mfp-img" />').on("load.mfploader", function() {
                        item.hasSize = true;
                    }).on("error.mfploader", function() {
                        item.hasSize = true;
                        item.loadError = true;
                    }).attr("src", item.src);
                }
                item.preloaded = true;
            }
        }
    });
    var RETINA_NS = "retina";
    $.magnificPopup.registerModule(RETINA_NS, {
        options: {
            replaceSrc: function(item) {
                return item.src.replace(/\.\w+$/, function(m) {
                    return "@2x" + m;
                });
            },
            ratio: 1
        },
        proto: {
            initRetina: function() {
                if (window.devicePixelRatio > 1) {
                    var st = mfp.st.retina, ratio = st.ratio;
                    ratio = !isNaN(ratio) ? ratio : ratio();
                    if (ratio > 1) {
                        _mfpOn("ImageHasSize" + "." + RETINA_NS, function(e, item) {
                            item.img.css({
                                "max-width": item.img[0].naturalWidth / ratio,
                                width: "100%"
                            });
                        });
                        _mfpOn("ElementParse" + "." + RETINA_NS, function(e, item) {
                            item.src = st.replaceSrc(item, ratio);
                        });
                    }
                }
            }
        }
    });
    (function() {
        var ghostClickDelay = 1e3, supportsTouch = "ontouchstart" in window, unbindTouchMove = function() {
            _window.off("touchmove" + ns + " touchend" + ns);
        }, eName = "mfpFastClick", ns = "." + eName;
        $.fn.mfpFastClick = function(callback) {
            return $(this).each(function() {
                var elem = $(this), lock;
                if (supportsTouch) {
                    var timeout, startX, startY, pointerMoved, point, numPointers;
                    elem.on("touchstart" + ns, function(e) {
                        pointerMoved = false;
                        numPointers = 1;
                        point = e.originalEvent ? e.originalEvent.touches[0] : e.touches[0];
                        startX = point.clientX;
                        startY = point.clientY;
                        _window.on("touchmove" + ns, function(e) {
                            point = e.originalEvent ? e.originalEvent.touches : e.touches;
                            numPointers = point.length;
                            point = point[0];
                            if (Math.abs(point.clientX - startX) > 10 || Math.abs(point.clientY - startY) > 10) {
                                pointerMoved = true;
                                unbindTouchMove();
                            }
                        }).on("touchend" + ns, function(e) {
                            unbindTouchMove();
                            if (pointerMoved || numPointers > 1) {
                                return;
                            }
                            lock = true;
                            e.preventDefault();
                            clearTimeout(timeout);
                            timeout = setTimeout(function() {
                                lock = false;
                            }, ghostClickDelay);
                            callback();
                        });
                    });
                }
                elem.on("click" + ns, function() {
                    if (!lock) {
                        callback();
                    }
                });
            });
        };
        $.fn.destroyMfpFastClick = function() {
            $(this).off("touchstart" + ns + " click" + ns);
            if (supportsTouch) _window.off("touchmove" + ns + " touchend" + ns);
        };
    })();
})(window.jQuery || window.Zepto);

(function() {
    "use strict";
    var responsiveNav = function(el, options) {
        var computed = !!window.getComputedStyle;
        if (!computed) {
            window.getComputedStyle = function(el) {
                this.el = el;
                this.getPropertyValue = function(prop) {
                    var re = /(\-([a-z]){1})/g;
                    if (prop === "float") {
                        prop = "styleFloat";
                    }
                    if (re.test(prop)) {
                        prop = prop.replace(re, function() {
                            return arguments[2].toUpperCase();
                        });
                    }
                    return el.currentStyle[prop] ? el.currentStyle[prop] : null;
                };
                return this;
            };
        }
        var addEvent = function(el, evt, fn, bubble) {
            if ("addEventListener" in el) {
                try {
                    el.addEventListener(evt, fn, bubble);
                } catch (e) {
                    if (typeof fn === "object" && fn.handleEvent) {
                        el.addEventListener(evt, function(e) {
                            fn.handleEvent.call(fn, e);
                        }, bubble);
                    } else {
                        throw e;
                    }
                }
            } else if ("attachEvent" in el) {
                if (typeof fn === "object" && fn.handleEvent) {
                    el.attachEvent("on" + evt, function() {
                        fn.handleEvent.call(fn);
                    });
                } else {
                    el.attachEvent("on" + evt, fn);
                }
            }
        }, removeEvent = function(el, evt, fn, bubble) {
            if ("removeEventListener" in el) {
                try {
                    el.removeEventListener(evt, fn, bubble);
                } catch (e) {
                    if (typeof fn === "object" && fn.handleEvent) {
                        el.removeEventListener(evt, function(e) {
                            fn.handleEvent.call(fn, e);
                        }, bubble);
                    } else {
                        throw e;
                    }
                }
            } else if ("detachEvent" in el) {
                if (typeof fn === "object" && fn.handleEvent) {
                    el.detachEvent("on" + evt, function() {
                        fn.handleEvent.call(fn);
                    });
                } else {
                    el.detachEvent("on" + evt, fn);
                }
            }
        }, getChildren = function(e) {
            if (e.children.length < 1) {
                throw new Error("The Nav container has no containing elements");
            }
            var children = [];
            for (var i = 0; i < e.children.length; i++) {
                if (e.children[i].nodeType === 1) {
                    children.push(e.children[i]);
                }
            }
            return children;
        }, setAttributes = function(el, attrs) {
            for (var key in attrs) {
                el.setAttribute(key, attrs[key]);
            }
        }, addClass = function(el, cls) {
            if (el.className.indexOf(cls) !== 0) {
                el.className += " " + cls;
                el.className = el.className.replace(/(^\s*)|(\s*$)/g, "");
            }
        }, removeClass = function(el, cls) {
            var reg = new RegExp("(\\s|^)" + cls + "(\\s|$)");
            el.className = el.className.replace(reg, " ").replace(/(^\s*)|(\s*$)/g, "");
        };
        var nav, opts, navToggle, styleElement = document.createElement("style"), hasAnimFinished, navOpen;
        var ResponsiveNav = function(el, options) {
            var i;
            this.options = {
                animate: true,
                transition: 250,
                label: "Menu",
                insert: "after",
                customToggle: "",
                openPos: "relative",
                navClass: "nav-collapse",
                jsClass: "js",
                init: function() {},
                open: function() {},
                close: function() {}
            };
            for (i in options) {
                this.options[i] = options[i];
            }
            addClass(document.documentElement, this.options.jsClass);
            this.wrapperEl = el.replace("#", "");
            if (document.getElementById(this.wrapperEl)) {
                this.wrapper = document.getElementById(this.wrapperEl);
            } else if (document.querySelector(this.wrapperEl)) {
                this.wrapper = document.querySelector(this.wrapperEl);
            } else {
                throw new Error("The nav element you are trying to select doesn't exist");
            }
            this.wrapper.inner = getChildren(this.wrapper);
            opts = this.options;
            nav = this.wrapper;
            this._init(this);
        };
        ResponsiveNav.prototype = {
            destroy: function() {
                this._removeStyles();
                removeClass(nav, "closed");
                removeClass(nav, "opened");
                removeClass(nav, opts.navClass);
                nav.removeAttribute("style");
                nav.removeAttribute("aria-hidden");
                removeEvent(window, "resize", this, false);
                removeEvent(document.body, "touchmove", this, false);
                removeEvent(navToggle, "touchstart", this, false);
                removeEvent(navToggle, "touchend", this, false);
                removeEvent(navToggle, "mouseup", this, false);
                removeEvent(navToggle, "keyup", this, false);
                removeEvent(navToggle, "click", this, false);
                if (!opts.customToggle) {
                    navToggle.parentNode.removeChild(navToggle);
                } else {
                    navToggle.removeAttribute("aria-hidden");
                }
            },
            toggle: function() {
                if (hasAnimFinished === true) {
                    if (!navOpen) {
                        removeClass(nav, "closed");
                        addClass(nav, "opened");
                        nav.style.position = opts.openPos;
                        setAttributes(nav, {
                            "aria-hidden": "false"
                        });
                        navOpen = true;
                        opts.open();
                    } else {
                        removeClass(nav, "opened");
                        addClass(nav, "closed");
                        setAttributes(nav, {
                            "aria-hidden": "true"
                        });
                        if (opts.animate) {
                            hasAnimFinished = false;
                            setTimeout(function() {
                                nav.style.position = "absolute";
                                hasAnimFinished = true;
                            }, opts.transition + 10);
                        } else {
                            nav.style.position = "absolute";
                        }
                        navOpen = false;
                        opts.close();
                    }
                }
            },
            resize: function() {
                if (window.getComputedStyle(navToggle, null).getPropertyValue("display") !== "none") {
                    setAttributes(navToggle, {
                        "aria-hidden": "false"
                    });
                    if (nav.className.match(/(^|\s)closed(\s|$)/)) {
                        setAttributes(nav, {
                            "aria-hidden": "true"
                        });
                        nav.style.position = "absolute";
                    }
                    this._createStyles();
                    this._calcHeight();
                } else {
                    setAttributes(navToggle, {
                        "aria-hidden": "true"
                    });
                    setAttributes(nav, {
                        "aria-hidden": "false"
                    });
                    nav.style.position = opts.openPos;
                    this._removeStyles();
                }
            },
            handleEvent: function(e) {
                var evt = e || window.event;
                switch (evt.type) {
                  case "touchstart":
                    this._onTouchStart(evt);
                    break;

                  case "touchmove":
                    this._onTouchMove(evt);
                    break;

                  case "touchend":
                  case "mouseup":
                    this._onTouchEnd(evt);
                    break;

                  case "click":
                    this._preventDefault(evt);
                    break;

                  case "keyup":
                    this._onKeyUp(evt);
                    break;

                  case "resize":
                    this.resize(evt);
                    break;
                }
            },
            _init: function() {
                addClass(nav, opts.navClass);
                addClass(nav, "closed");
                hasAnimFinished = true;
                navOpen = false;
                this._createToggle();
                this._transitions();
                this.resize();
                var self = this;
                setTimeout(function() {
                    self.resize();
                }, 20);
                addEvent(window, "resize", this, false);
                addEvent(document.body, "touchmove", this, false);
                addEvent(navToggle, "touchstart", this, false);
                addEvent(navToggle, "touchend", this, false);
                addEvent(navToggle, "mouseup", this, false);
                addEvent(navToggle, "keyup", this, false);
                addEvent(navToggle, "click", this, false);
                opts.init();
            },
            _createStyles: function() {
                if (!styleElement.parentNode) {
                    styleElement.type = "text/css";
                    document.getElementsByTagName("head")[0].appendChild(styleElement);
                }
            },
            _removeStyles: function() {
                if (styleElement.parentNode) {
                    styleElement.parentNode.removeChild(styleElement);
                }
            },
            _createToggle: function() {
                if (!opts.customToggle) {
                    var toggle = document.createElement("a");
                    toggle.innerHTML = opts.label;
                    setAttributes(toggle, {
                        href: "#",
                        "class": "nav-toggle"
                    });
                    if (opts.insert === "after") {
                        nav.parentNode.insertBefore(toggle, nav.nextSibling);
                    } else {
                        nav.parentNode.insertBefore(toggle, nav);
                    }
                    navToggle = toggle;
                } else {
                    var toggleEl = opts.customToggle.replace("#", "");
                    if (document.getElementById(toggleEl)) {
                        navToggle = document.getElementById(toggleEl);
                    } else if (document.querySelector(toggleEl)) {
                        navToggle = document.querySelector(toggleEl);
                    } else {
                        throw new Error("The custom nav toggle you are trying to select doesn't exist");
                    }
                }
            },
            _preventDefault: function(e) {
                if (e.preventDefault) {
                    e.preventDefault();
                    e.stopPropagation();
                } else {
                    e.returnValue = false;
                }
            },
            _onTouchStart: function(e) {
                e.stopPropagation();
                addClass(nav, "disable-pointer-events");
                this.startX = e.touches[0].clientX;
                this.startY = e.touches[0].clientY;
                this.touchHasMoved = false;
                removeEvent(navToggle, "mouseup", this, false);
            },
            _onTouchMove: function(e) {
                if (Math.abs(e.touches[0].clientX - this.startX) > 10 || Math.abs(e.touches[0].clientY - this.startY) > 10) {
                    this.touchHasMoved = true;
                }
            },
            _onTouchEnd: function(e) {
                this._preventDefault(e);
                if (!this.touchHasMoved) {
                    if (e.type === "touchend") {
                        this.toggle(e);
                        setTimeout(function() {
                            removeClass(nav, "disable-pointer-events");
                        }, opts.transition + 300);
                        return;
                    } else {
                        var evt = e || window.event;
                        if (!(evt.which === 3 || evt.button === 2)) {
                            this.toggle(e);
                        }
                    }
                }
            },
            _onKeyUp: function(e) {
                var evt = e || window.event;
                if (evt.keyCode === 13) {
                    this.toggle(e);
                }
            },
            _transitions: function() {
                if (opts.animate) {
                    var objStyle = nav.style, transition = "max-height " + opts.transition + "ms";
                    objStyle.WebkitTransition = transition;
                    objStyle.MozTransition = transition;
                    objStyle.OTransition = transition;
                    objStyle.transition = transition;
                }
            },
            _calcHeight: function() {
                var savedHeight = 0;
                for (var i = 0; i < nav.inner.length; i++) {
                    savedHeight += nav.inner[i].offsetHeight;
                }
                var innerStyles = "." + opts.navClass + ".opened{max-height:" + savedHeight + "px !important}";
                if (styleElement.styleSheet) {
                    styleElement.styleSheet.cssText = innerStyles;
                } else {
                    styleElement.innerHTML = innerStyles;
                }
                innerStyles = "";
            }
        };
        return new ResponsiveNav(el, options);
    };
    window.responsiveNav = responsiveNav;
})();

jQuery(document).ready(function() {
    $(".ib").popover();
    function scrollToAnchor(aid) {
        var aTag = $("a[name='" + aid + "']");
        $("html,body").animate({
            scrollTop: aTag.offset().top
        }, "slow");
    }
    $(".ugrogomb").click(function() {
        event.preventDefault();
        scrollToAnchor($(this).attr("href").replace("#", ""));
    });
    var $container = $(".product-listing");
    $container.isotope({
        animationOptions: {
            duration: 750,
            easing: "linear",
            queue: false
        }
    });
    $(".prodcat-menu a").click(function() {
        var selector = $(this).attr("data-filter");
        $container.isotope({
            filter: selector
        });
        return false;
    });
});

var navigation = responsiveNav("#nav", {
    animate: true,
    transition: 400,
    label: "Men",
    insert: "after",
    customToggle: "nav-toggle",
    openPos: "relative",
    jsClass: "js",
    init: function() {},
    open: function() {},
    close: function() {}
});